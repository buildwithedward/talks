{"prompt":"Write a Rust function that calculates the factorial of a given non-negative integer.","response":"```rust\nfn factorial(n: u32) -> u32 {\n    if n == 0 {\n        return 1;\n    } else {\n        let mut result = 1;\n        for i in 1..=n {\n            result *= i;\n        }\n        return result;\n    }\n}\n```\nIn this code, we define a function called `factorial` that takes a non-negative integer `n` as input. Inside the function, we handle the base case where `n` is 0 and return 1, as the factorial of 0 is defined to be 1. For `n` greater than 0, we initialize a variable `result` with the initial value of 1. Then, we use a `for` loop to iterate from 1 to `n` (inclusive). In each iteration, we multiply the current value of `result` by the current value of `i` and update the value of `result` accordingly. Finally, we return the value of `result` as the factorial of `n`."}
{"prompt":"Write a Rust function that checks whether a given string is a valid palindrome, ignoring spaces and punctuation.","response":"```rust\nfn is_valid_palindrome(s: &str) -> bool {\n    let sanitized = s.chars()\n        .filter(|c| c.is_alphanumeric())\n        .collect::<String>();\n    let reversed = sanitized.chars().rev().collect::<String>();\n    return sanitized.eq_ignore_ascii_case(&reversed);\n}\n```\nIn this code, we define a function called `is_valid_palindrome` that takes a string `s` as input. Inside the function, we first sanitize the input string by removing all non-alphanumeric characters using the `filter` method on the string's characters. We then collect the sanitized characters back into a `String` using `collect::<String>()`. This gives us a sanitized version of the input string.\n\nNext, we reverse the sanitized string by using the `rev` method on its characters, and collect them back into a `String`. This gives us the reversed version of the sanitized string.\n\nFinally, we compare the sanitized string with the reversed string, ignoring ASCII case differences, using the `eq_ignore_ascii_case` method. If the two strings are equal, we return `true` to indicate that the input string is a valid palindrome. Otherwise, we return `false`."}
{"prompt":"Write a Rust function that finds the maximum element in a given array of integers.","response":"```rust\nfn find_max(arr: &[i32]) -> Option<i32> {\n    if arr.is_empty() {\n        return None;\n    }\n    \n    let mut max = arr[0];\n    for &num in arr.iter() {\n        if num > max {\n            max = num;\n        }\n    }\n    \n    return Some(max);\n}\n```\nIn this code, we define a function called `find_max` that takes a slice of integers `arr` as input. Inside the function, we first check if the array is empty using the `is_empty` method. If it is, we return `None` to indicate that there is no maximum element. Otherwise, we initialize a variable `max` with the first element of the array. Then, we iterate over each element of the array using the `iter` method and compare each element with the current maximum. If we find an element greater than the current maximum, we update the value of `max`. Finally, we return `Some(max)` to indicate that we found the maximum element in the array."}
{"prompt":"Write a Rust function that calculates the sum of all elements in a given array of integers.","response":"```rust\nfn sum_array(arr: &[i32]) -> i32 {\n    let mut sum = 0;\n    for &num in arr {\n        sum += num;\n    }\n    return sum;\n}\n```\nIn this code, we define a function called `sum_array` that takes a slice of integers `arr` as input. Inside the function, we initialize a variable `sum` with 0 to keep track of the sum of all elements. Then, we iterate over each element of the array using the `for` loop and add each element to the `sum` variable. Finally, we return the value of `sum` as the result of the function."}
{"prompt":"Write a Rust function that calculates the factorial of a given number using recursion.","response":"```rust\nfn factorial(n: u32) -> u32 {\n    if n == 0 {\n        return 1;\n    } else {\n        return n * factorial(n - 1);\n    }\n}\n```\nIn this code, we define a function called `factorial` that takes an unsigned integer `n` as input. Inside the function, we use a recursive approach to calculate the factorial of `n`. If `n` is equal to 0, we return 1 as the base case. Otherwise, we multiply `n` with the factorial of `n-1` and return the result. This recursive calculation continues until `n` becomes 0."}
{"prompt":"Write a Rust function that calculates the sum of all even numbers in a given array of integers.","response":"```rust\nfn sum_even_numbers(arr: &[i32]) -> i32 {\n    let mut sum = 0;\n    for &num in arr {\n        if num % 2 == 0 {\n            sum += num;\n        }\n    }\n    return sum;\n}\n```\nIn this code, we define a function called `sum_even_numbers` that takes a slice of integers `arr` as input. Inside the function, we initialize a variable `sum` with 0 to keep track of the sum of even numbers. Then, we iterate over each element of the array using the `for` loop and check if the current element is even by using the modulo operator `%`. If the element is even, we add it to the `sum` variable. Finally, we return the value of `sum` as the result of the function."}
{"prompt":"Write a Rust function that calculates the sum of all elements in a given array of integers.","response":"```rust\nfn sum_array(arr: &[i32]) -> i32 {\n    let mut sum = 0;\n    for &num in arr {\n        sum += num;\n    }\n    return sum;\n}\n```\nIn this code, we define a function called `sum_array` that takes a slice of integers `arr` as input. Inside the function, we initialize a variable `sum` with 0 to keep track of the sum of all elements. Then, we iterate over each element of the array using the `for` loop and add each element to the `sum` variable. Finally, we return the value of `sum` as the result of the function, which represents the sum of all elements in the array."}
{"prompt":"Write a Rust function that calculates the sum of all elements in a given array of integers.","response":"```rust\nfn sum_array(arr: &[i32]) -> i32 {\n    let mut sum = 0;\n    for &num in arr {\n        sum += num;\n    }\n    return sum;\n}\n```\nIn this code, we define a function called `sum_array` that takes a slice of integers `arr` as input. Inside the function, we initialize a variable `sum` with 0 to keep track of the sum of all elements. Then, we use a `for` loop to iterate over each element of the array and add each element to the `sum` variable. Finally, we return the value of `sum` as the result of the function."}
{"prompt":"Write a Rust function that checks whether a given number is even or odd.","response":"```rust\nfn is_even_odd(n: i32) -> String {\n    if n % 2 == 0 {\n        return String::from(\"Even\");\n    } else {\n        return String::from(\"Odd\");\n    }\n}\n```\nIn this code, we define a function called `is_even_odd` that takes an integer `n` as input. Inside the function, we use the modulo operator `%` to check if `n` is divisible by 2. If the remainder is 0, it means `n` is even, so we return the string \"Even\". Otherwise, we return the string \"Odd\" to indicate that `n` is odd. The return type of the function is `String` to allow for returning different string values."}
{"prompt":"Write a Rust function that takes two integers as input and returns their sum.","response":"```rust\nfn add_numbers(a: i32, b: i32) -> i32 {\n    let sum = a + b;\n    return sum;\n}\n```\nHere, we define a function called `add_numbers` that takes two integers `a` and `b` as input. Inside the function, we declare a variable `sum` and assign the sum of `a` and `b` to it. Finally, we return the value of `sum` as the result of the function."}
{"prompt":"Write a Rust function that sorts a given array of integers in ascending order.","response":"```rust\nfn sort_array(arr: &mut [i32]) {\n    arr.sort();\n}\n```\nHere, we define a function called `sort_array` that takes a mutable slice of integers `arr` as input. Inside the function, we use the `sort` method provided by Rust's standard library to sort the elements of the array in ascending order. The `sort` method modifies the array in place, so there is no need to return anything from the function. After calling this function, the elements in the array will be sorted in ascending order."}
{"prompt":"Write a Rust function that calculates the factorial of a given non-negative integer.","response":"```rust\nfn factorial(n: u32) -> u32 {\n    if n == 0 {\n        return 1;\n    }\n    \n    let mut result = 1;\n    for i in 1..=n {\n        result *= i;\n    }\n    \n    return result;\n}\n```\nIn this code, we define a function called `factorial` that takes a non-negative integer `n` as input. Inside the function, we handle the base case where `n` is 0 and return 1, as the factorial of 0 is defined to be 1. For `n` greater than 0, we initialize a variable `result` with 1 to keep track of the factorial value. Then, we use a `for` loop to iterate from 1 to `n` (inclusive) and multiply each value of `i` with `result`. This calculates the factorial of `n`. Finally, we return the value of `result` as the result of the function."}
{"prompt":"Write a Rust function that calculates the Fibonacci sequence up to a given number of terms.","response":"```rust\nfn fibonacci(n: u32) -> Vec<u32> {\n    let mut sequence = vec![0, 1];\n    \n    while sequence.len() < n as usize {\n        let next = sequence[sequence.len() - 1] + sequence[sequence.len() - 2];\n        sequence.push(next);\n    }\n    \n    return sequence;\n}\n```\nIn this code, we define a function called `fibonacci` that takes an unsigned integer `n` as input. Inside the function, we initialize a vector called `sequence` with the first two terms of the Fibonacci sequence, which are 0 and 1. We then use a `while` loop to generate the remaining terms of the sequence until the length of the `sequence` vector becomes equal to `n`. In each iteration of the loop, we calculate the next term by adding the last two terms of the `sequence` vector. We then push the next term to the `sequence` vector. Finally, we return the `sequence` vector, which contains the Fibonacci sequence up to `n` terms."}
{"prompt":"Write a Rust function that calculates the sum of all even numbers in a given array of integers.","response":"```rust\nfn sum_even_numbers(arr: &[i32]) -> i32 {\n    let mut sum = 0;\n    for &num in arr {\n        if num % 2 == 0 {\n            sum += num;\n        }\n    }\n    return sum;\n}\n```\nIn this code, we define a function called `sum_even_numbers` that takes a slice of integers `arr` as input. Inside the function, we initialize a variable `sum` with the initial value of 0. Then, we use a `for` loop to iterate over each element `num` in the array. In each iteration, we check if the current element is even by using the modulo operator `%` to check if the remainder of dividing `num` by 2 is 0. If the element is even, we add its value to the current value of `sum`. Finally, we return the value of `sum` as the sum of all even numbers in the array."}
{"prompt":"Write a Rust function that calculates the sum of all elements in a given array of integers.","response":"```rust\nfn sum_array(arr: &[i32]) -> i32 {\n    let mut sum = 0;\n    for &num in arr {\n        sum += num;\n    }\n    return sum;\n}\n```\nIn this code, we define a function called `sum_array` that takes a slice of integers `arr` as input. Inside the function, we initialize a variable `sum` with the initial value of 0. Then, we use a `for` loop to iterate over each element `num` in the array. In each iteration, we add the value of `num` to the current value of `sum`. Finally, we return the value of `sum` as the sum of all elements in the array."}
{"prompt":"Write a Rust function that checks whether a given string is a palindrome or not.","response":"```rust\nfn is_palindrome(s: &str) -> bool {\n    let s = s.chars().filter(|c| c.is_alphanumeric()).collect::<String>().to_lowercase();\n    let reversed = s.chars().rev().collect::<String>();\n    return s == reversed;\n}\n```\nIn this code, we define a function called `is_palindrome` that takes a string `s` as input. Inside the function, we first remove any non-alphanumeric characters from the string by using the `chars` method to iterate over each character, the `filter` method to keep only alphanumeric characters, and the `collect` method to collect the filtered characters into a new string. We also convert the string to lowercase to ignore case sensitivity. Then, we create a new string `reversed` by reversing the characters of `s`. Finally, we compare the filtered and reversed strings to check if they are equal. If they are equal, it means the original string is a palindrome, so we return `true`. Otherwise, we return `false`."}
{"prompt":"Write a Rust function that calculates the factorial of a given number.","response":"```rust\nfn factorial(n: u32) -> u32 {\n    if n == 0 {\n        return 1;\n    } else {\n        return n * factorial(n - 1);\n    }\n}\n```\nIn this code, we define a function called `factorial` that takes an unsigned integer `n` as input. Inside the function, we use a recursive approach to calculate the factorial of `n`. If `n` is equal to 0, we return 1 as the base case. Otherwise, we multiply `n` with the factorial of `n-1` and return the result. This recursive calculation continues until `n` becomes 0."}
{"prompt":"Write a Rust function that checks whether a given string is a palindrome or not.","response":"```rust\nfn is_palindrome(s: &str) -> bool {\n    let reversed = s.chars().rev().collect::<String>();\n    return s == reversed;\n}\n```\nHere, we define a function called `is_palindrome` that takes a string `s` as input. Inside the function, we use the `chars` method to convert the string into an iterator of characters. We then use the `rev` method to reverse the order of the characters, and finally, we collect them back into a `String` using `collect::<String>()`. This gives us the reversed version of the input string. We then compare the original string `s` with the reversed string and return `true` if they are equal, indicating that the string is a palindrome. Otherwise, we return `false`."}
{"prompt":"Write a Rust function that calculates the Fibonacci sequence up to a given number of terms.","response":"```rust\nfn fibonacci(n: u32) -> Vec<u32> {\n    let mut sequence = vec![0, 1];\n    \n    for i in 2..n {\n        let next = sequence[i as usize - 1] + sequence[i as usize - 2];\n        sequence.push(next);\n    }\n    \n    return sequence;\n}\n```\nIn this code, we define a function called `fibonacci` that takes an unsigned integer `n` as input. Inside the function, we initialize a vector called `sequence` with the first two terms of the Fibonacci sequence: 0 and 1. Then, we use a `for` loop to iterate from 2 to `n`. In each iteration, we calculate the next term of the sequence by adding the last two terms together, and then we push the next term to the `sequence` vector. Finally, we return the `sequence` vector, which contains the Fibonacci sequence up to `n` terms."}
{"prompt":"Write a Rust function that finds the maximum element in a given array of integers.","response":"```rust\nfn find_max(arr: &[i32]) -> Option<i32> {\n    if arr.is_empty() {\n        return None;\n    }\n    \n    let mut max = arr[0];\n    for &num in arr.iter() {\n        if num > max {\n            max = num;\n        }\n    }\n    \n    return Some(max);\n}\n```\nIn this code, we define a function called `find_max` that takes a slice of integers `arr` as input. Inside the function, we first check if the array is empty. If it is, we return `None` to indicate that there is no maximum element. Otherwise, we initialize a variable `max` with the first element of the array. Then, we iterate over each element of the array using the `iter` method and compare each element with the current maximum. If we find an element greater than the current maximum, we update the value of `max`. Finally, we return `Some(max)` to indicate that we found the maximum element in the array."}
{"prompt":"Write a Rust function that calculates the sum of all even numbers in a given array of integers.","response":"```rust\nfn sum_of_even_numbers(arr: &[i32]) -> i32 {\n    let mut sum = 0;\n    \n    for &num in arr.iter() {\n        if num % 2 == 0 {\n            sum += num;\n        }\n    }\n    \n    return sum;\n}\n```\nIn this code, we define a function called `sum_of_even_numbers` that takes a slice of integers `arr` as input. Inside the function, we initialize a variable `sum` with 0 to keep track of the sum of even numbers. Then, we iterate over each element of the array using the `iter` method and check if the element is even by using the modulo operator `%`. If the element is even, we add it to the `sum` variable. Finally, we return the value of `sum` as the result of the function, which represents the sum of all even numbers in the array."}
{"prompt":"Write a Rust function that checks whether a given number is positive, negative, or zero.","response":"```rust\nfn check_number(n: i32) -> String {\n    if n > 0 {\n        return String::from(\"Positive\");\n    } else if n < 0 {\n        return String::from(\"Negative\");\n    } else {\n        return String::from(\"Zero\");\n    }\n}\n```\nIn this code, we define a function called `check_number` that takes an integer `n` as input. Inside the function, we use conditional statements (`if`, `else if`, and `else`) to check the value of `n`. If `n` is greater than 0, we return the string \"Positive\". If `n` is less than 0, we return the string \"Negative\". Otherwise, we return the string \"Zero\" to indicate that `n` is equal to 0. The return type of the function is `String` to allow for returning different string values."}
{"prompt":"Write a Rust function that checks whether a given number is prime or not.","response":"```rust\nfn is_prime(n: u32) -> bool {\n    if n < 2 {\n        return false;\n    }\n    \n    for i in 2..(n as f64).sqrt() as u32 + 1 {\n        if n % i == 0 {\n            return false;\n        }\n    }\n    \n    return true;\n}\n```\nIn this code, we define a function called `is_prime` that takes an unsigned integer `n` as input. Inside the function, we first check if `n` is less than 2. If it is, we return `false` because prime numbers are greater than 1. Then, we use a `for` loop to iterate from 2 to the square root of `n` (casted to `f64`) plus 1. In each iteration, we check if `n` is divisible by the current value of `i`. If it is, we return `false` because `n` is not a prime number. Finally, if the loop completes without finding any divisors, we return `true` to indicate that `n` is a prime number."}
{"prompt":"Write a Rust function that checks whether a given string is a palindrome or not.","response":"```rust\nfn is_palindrome(s: &str) -> bool {\n    let reversed = s.chars().rev().collect::<String>();\n    return s == reversed;\n}\n```\nIn this code, we define a function called `is_palindrome` that takes a string `s` as input. Inside the function, we use the `chars` method to convert the string into an iterator of characters. We then use the `rev` method to reverse the order of the characters, and finally, we collect them back into a `String` using `collect::<String>()`. This gives us the reversed version of the input string. We then compare the original string `s` with the reversed string and return `true` if they are equal, indicating that the string is a palindrome. Otherwise, we return `false`."}
{"prompt":"Write a Rust function that calculates the sum of all odd numbers in a given array of integers.","response":"```rust\nfn sum_odd_numbers(arr: &[i32]) -> i32 {\n    let mut sum = 0;\n    for &num in arr {\n        if num % 2 != 0 {\n            sum += num;\n        }\n    }\n    return sum;\n}\n```\nIn this code, we define a function called `sum_odd_numbers` that takes a slice of integers `arr` as input. Inside the function, we initialize a variable `sum` with 0 to keep track of the sum of odd numbers. Then, we iterate over each element of the array using the `for` loop and check if the current element is odd by using the modulo operator `%`. If the element is odd (i.e., not divisible by 2), we add it to the `sum` variable. Finally, we return the value of `sum` as the result of the function."}
{"prompt":"Write a Rust function that calculates the nth term of the Fibonacci sequence.","response":"```rust\nfn fibonacci(n: u32) -> u32 {\n    if n == 0 {\n        return 0;\n    } else if n == 1 {\n        return 1;\n    } else {\n        let mut prev = 0;\n        let mut curr = 1;\n        \n        for _ in 2..=n {\n            let next = prev + curr;\n            prev = curr;\n            curr = next;\n        }\n        \n        return curr;\n    }\n}\n```\nIn this code, we define a function called `fibonacci` that takes an unsigned integer `n` as input. Inside the function, we handle the base cases where `n` is 0 or 1, and return the corresponding values of the Fibonacci sequence. For `n` greater than 1, we initialize two variables `prev` and `curr` with the first two terms of the sequence, which are 0 and 1 respectively. We then use a `for` loop to calculate the next term of the sequence by adding `prev` and `curr`, and update the values of `prev` and `curr` accordingly. This loop runs `n-1` times to calculate the `n`th term of the sequence. Finally, we return the value of `curr`, which represents the `n`th term of the Fibonacci sequence."}
{"prompt":"Write a Rust function that checks whether a given number is prime or not.","response":"```rust\nfn is_prime(n: u32) -> bool {\n    if n <= 1 {\n        return false;\n    }\n    \n    for i in 2..=n\/2 {\n        if n % i == 0 {\n            return false;\n        }\n    }\n    \n    return true;\n}\n```\nIn this code, we define a function called `is_prime` that takes an unsigned integer `n` as input. Inside the function, we first check if `n` is less than or equal to 1. If it is, we return `false` since 1 and all negative numbers are not prime. Then, we use a `for` loop to iterate from 2 to `n\/2` and check if `n` is divisible by any number in that range. If we find a divisor, we return `false` indicating that `n` is not prime. If no divisor is found, we return `true` indicating that `n` is prime."}
